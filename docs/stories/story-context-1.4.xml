<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>1.4</storyId>
    <title>Create Core Data Models (Models, Capabilities, Benchmarks)</title>
    <status>Ready</status>
    <generatedAt>2025-10-16</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/story-1.4.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>a developer</asA>
    <iWant>database schema for LLM models, capabilities, and benchmarks implemented with Entity Framework Core</iWant>
    <soThat>I can store and retrieve model data with proper relationships and constraints</soThat>
    <tasks>
      1. Create Model entity in Domain layer (AC: 1)
      2. Create Capability entity in Domain layer (AC: 2)
      3. Create Benchmark entity in Domain layer (AC: 3)
      4. Create BenchmarkScore entity in Domain layer (AC: 4)
      5. Configure entity relationships and constraints in Infrastructure layer (AC: 5)
      6. Register entity configurations in AppDbContext (AC: 5)
      7. Generate and apply database migration (AC: 6)
      8. Validate schema and create verification tests (AC: 6)
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="AC1">Models table entity created with all required fields: id, name, provider, version, release_date, status, input_price_per_1M, output_price_per_1M, currency, pricing_valid_from, pricing_valid_to, last_scraped_at, is_active, created_at, updated_at</criterion>
    <criterion id="AC2">ModelCapabilities table entity created with fields: id, model_id, context_window, max_output_tokens, supports_function_calling, supports_vision, supports_audio_input, supports_audio_output, supports_streaming, supports_json_mode</criterion>
    <criterion id="AC3">Benchmarks table entity created with fields: id, benchmark_name, full_name, description, category, interpretation, typical_range_min, typical_range_max</criterion>
    <criterion id="AC4">ModelBenchmarkScores table entity created with fields: id, model_id, benchmark_id, score, max_score, test_date, source_url, verified, notes</criterion>
    <criterion id="AC5">Entity relationships configured: one-to-one Models to Capabilities, one-to-many Models to BenchmarkScores, many-to-one BenchmarkScores to Benchmarks</criterion>
    <criterion id="AC6">Database migration generated and applied successfully, creating all 4 tables with indexes and constraints</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/solution-architecture.md</path>
        <title>Solution Architecture Document</title>
        <section>Section 2.1 - Hexagonal Architecture</section>
        <snippet>Domain entities are PURE POCOs with no EF annotations. Configuration lives in Infrastructure via Fluent API in IEntityTypeConfiguration classes. Navigation properties are one-way by default.</snippet>
      </doc>
      <doc>
        <path>docs/solution-architecture.md</path>
        <title>Solution Architecture Document</title>
        <section>Section 3.1 - Database Schema (inferred)</section>
        <snippet>Table naming uses snake_case per PostgreSQL conventions. All entities use GUID (UUID) primary keys. Timestamps track created_at and updated_at. Models use is_active flag for soft deletion. Decimal precision: pricing fields use decimal(10,6), scores use decimal(6,2).</snippet>
      </doc>
      <doc>
        <path>docs/tech-spec-epic-1.md</path>
        <title>Tech Spec: Epic 1 - Project Foundation</title>
        <section>Story 1.4: Create Core Data Models</section>
        <snippet>Model entity structure with GUID ID, pricing fields (InputPricePer1M, OutputPricePer1M), navigation properties (Capability, BenchmarkScores collection). EF Core configuration via IEntityTypeConfiguration with indexes on Provider, unique constraint on (Name, Provider), decimal(10,6) for pricing.</snippet>
      </doc>
      <doc>
        <path>docs/stories/story-1.4.md</path>
        <title>Story 1.4 Dev Notes</title>
        <section>Architecture Constraints</section>
        <snippet>Entity relationships: Model (1:1) Capability with cascade delete, Model (1:N) BenchmarkScore with cascade delete, Benchmark (1:N) BenchmarkScore with cascade delete. Indexes: models (provider, status, updated_at DESC), capabilities (model_id), benchmark_scores (model_id, benchmark_id).</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>services/backend/LlmTokenPrice.Infrastructure/Data/AppDbContext.cs</path>
        <kind>DbContext</kind>
        <symbol>AppDbContext</symbol>
        <lines>1-44</lines>
        <reason>Existing DbContext to be updated with DbSet properties and entity configurations. Comments indicate where Story 1.4 additions go (lines 26-30, 40-41).</reason>
      </artifact>
      <artifact>
        <path>services/backend/LlmTokenPrice.Domain/Class1.cs</path>
        <kind>placeholder</kind>
        <symbol>Class1</symbol>
        <lines>all</lines>
        <reason>Placeholder file in Domain layer to be replaced with actual entity classes in Entities/ directory.</reason>
      </artifact>
      <artifact>
        <path>services/backend/LlmTokenPrice.Infrastructure/Class1.cs</path>
        <kind>placeholder</kind>
        <symbol>Class1</symbol>
        <lines>all</lines>
        <reason>Placeholder file in Infrastructure layer. Will create Data/Configurations/ directory alongside existing Data/ directory.</reason>
      </artifact>
    </code>
    <dependencies>
      <dotnet>
        <package name="Microsoft.EntityFrameworkCore" version="9.0.10" source="inferred from .NET 9 target" />
        <package name="Microsoft.EntityFrameworkCore.Design" version="9.0.10" scope="development" />
        <package name="Npgsql.EntityFrameworkCore.PostgreSQL" version="~9.0" source="PostgreSQL 16 provider" />
      </dotnet>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>Domain entities MUST be pure POCOs - no EF attributes, no infrastructure dependencies, no data access logic</constraint>
    <constraint>All EF Core configuration MUST use Fluent API in IEntityTypeConfiguration&lt;T&gt; classes in Infrastructure layer</constraint>
    <constraint>Table names MUST use snake_case (models, model_capabilities, benchmarks, model_benchmark_scores) per PostgreSQL conventions</constraint>
    <constraint>All entities MUST use Guid (UUID) as primary key for distributed system compatibility</constraint>
    <constraint>Decimal precision MUST be explicit: pricing fields decimal(10,6), scores decimal(6,2), normalized scores decimal(5,4)</constraint>
    <constraint>Navigation properties are one-way by default: Model → Capability, Model → BenchmarkScores, BenchmarkScore → Benchmark</constraint>
    <constraint>Cascade delete MUST be configured for: Model deletes cascade to Capability and BenchmarkScores</constraint>
    <constraint>Unique constraints required: (Name, Provider) on Model, ModelId on Capability, BenchmarkName on Benchmark, (ModelId, BenchmarkId) on BenchmarkScore</constraint>
    <constraint>Indexes required for query performance: Provider, Status, UpdatedAt on Model; ModelId on Capability; ModelId and BenchmarkId on BenchmarkScore</constraint>
    <constraint>Namespace convention: LlmTokenPrice.Domain.Entities for entities, LlmTokenPrice.Infrastructure.Data.Configurations for EF configurations</constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>AppDbContext.OnModelCreating</name>
      <kind>EF Core model configuration</kind>
      <signature>protected override void OnModelCreating(ModelBuilder modelBuilder)</signature>
      <path>services/backend/LlmTokenPrice.Infrastructure/Data/AppDbContext.cs</path>
      <usage>Add modelBuilder.ApplyConfigurationsFromAssembly(Assembly.GetExecutingAssembly()) to auto-discover all IEntityTypeConfiguration classes</usage>
    </interface>
    <interface>
      <name>IEntityTypeConfiguration&lt;T&gt;</name>
      <kind>EF Core Fluent API interface</kind>
      <signature>public void Configure(EntityTypeBuilder&lt;T&gt; builder)</signature>
      <path>Microsoft.EntityFrameworkCore</path>
      <usage>Implement for each entity: ModelConfiguration, CapabilityConfiguration, BenchmarkConfiguration, BenchmarkScoreConfiguration</usage>
    </interface>
    <interface>
      <name>dotnet ef migrations add</name>
      <kind>EF Core CLI command</kind>
      <signature>dotnet ef migrations add [MigrationName] --project [InfraProject] --startup-project [ApiProject] --output-dir [Directory]</signature>
      <path>Entity Framework Core tools</path>
      <usage>Generate migration: dotnet ef migrations add InitialSchema --project LlmTokenPrice.Infrastructure --startup-project LlmTokenPrice.API --output-dir Data/Migrations</usage>
    </interface>
    <interface>
      <name>dotnet ef database update</name>
      <kind>EF Core CLI command</kind>
      <signature>dotnet ef database update --project [InfraProject] --startup-project [ApiProject]</signature>
      <path>Entity Framework Core tools</path>
      <usage>Apply migration to database after reviewing generated migration file</usage>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Unit tests use xUnit framework with FluentAssertions for readable assertions. Integration tests use TestContainers for PostgreSQL and should verify EF Core mappings, relationships, and constraints. Schema validation tests verify table structure via raw SQL queries against pg_catalog. All tests follow AAA pattern (Arrange, Act, Assert). Backend test location: Backend.Tests project (to be created in future story).
    </standards>
    <locations>
      <location>services/backend/LlmTokenPrice.Tests/Domain/Entities/</location>
      <location>services/backend/LlmTokenPrice.Tests/Infrastructure/Data/</location>
      <location>Manual validation via psql commands for this story (automated tests in later stories)</location>
    </locations>
    <ideas>
      <idea ac="AC1">Verify Model entity has all 15 required properties with correct types. Test default values (Status="active", Currency="USD", IsActive=true). Verify navigation properties initialized as empty collections.</idea>
      <idea ac="AC2">Verify Capability entity has ModelId foreign key, all capability boolean flags, and navigation property to Model. Test default values (SupportsStreaming=true).</idea>
      <idea ac="AC3">Verify Benchmark entity has unique BenchmarkName, Category enum values, Interpretation field. Test navigation property to Scores collection.</idea>
      <idea ac="AC4">Verify BenchmarkScore entity has composite foreign keys (ModelId, BenchmarkId), NormalizedScore field for QAPS calculation. Test navigation properties to Model and Benchmark.</idea>
      <idea ac="AC5">Integration test: Insert Model with Capability, verify one-to-one relationship. Insert Model with multiple BenchmarkScores, verify one-to-many. Delete Model, verify cascade delete removes Capability and BenchmarkScores.</idea>
      <idea ac="AC6">Schema validation: Query pg_indexes to verify indexes created. Query information_schema.table_constraints to verify unique constraints. Attempt duplicate insert to verify constraint enforcement. Query pg_catalog.pg_type to verify decimal precision.</idea>
    </ideas>
  </tests>
</story-context>
